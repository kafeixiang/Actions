# 工作流名称：每小时多仓库自动同步（变基/强制覆盖模式）
name: Multi-Repo Sync (Safety PR Mode)

on:
  schedule:
    - cron: '0 * * * *' # 定时触发：每小时运行一次
  workflow_dispatch:      # 手动触发

jobs:
  rebase-sync:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false     # 即使其中一个仓库报错，也要继续处理后续仓库
      matrix:
        include:
          # --- 待同步仓库清单 ---
          # 格式解析：
          # name: 仅用于日志显示的标签
          # fork: 你的仓库路径（用户名/仓库名）
          # upstream: 原作者的原始仓库地址
          # mappings: 分支对应关系，格式为 "上游分支:本地分支"。
          #           注意：若本地分支名以 ! 结尾（如 Alpha!），则使用强制覆盖（Hard Reset）；否则默认使用变基（Rebase）。

          - name: "mihomo"
            fork: "kafeixiang/mihomo"
            upstream: "https://github.com/MetaCubeX/mihomo.git"
            mappings: "Meta:Meta Alpha:Alpha!" # Meta 变基同步，Alpha 强制同步

          - name: "ClashMetaForAndroid"
            fork: "kafeixiang/ClashMetaForAndroid"
            upstream: "https://github.com/MetaCubeX/ClashMetaForAndroid.git"
            mappings: "main:main update-dependencies:update-dependencies! update-dependencies:dev"

          - name: "sing-box"
            fork: "kafeixiang/sing-box"
            upstream: "https://github.com/SagerNet/sing-box.git"
            mappings: "main-next:main-next"

          - name: "v2rayNG"
            fork: "kafeixiang/v2rayNG"
            upstream: "https://github.com/2dust/v2rayNG.git"
            mappings: "master:dev"

          - name: "v2rayN"
            fork: "kafeixiang/v2rayN"
            upstream: "https://github.com/2dust/v2rayN.git"
            mappings: "master:dev"

          - name: "NekoBoxForAndroid"
            fork: "kafeixiang/NekoBoxForAndroid"
            upstream: "https://github.com/MatsuriDayo/NekoBoxForAndroid.git"
            mappings: "main:dev"

          - name: "FlClash"
            fork: "kafeixiang/FlClash"
            upstream: "https://github.com/chen08209/FlClash.git"
            mappings: "main:main dev:dev!"

          - name: "Exclave"
            fork: "kafeixiang/Exclave"
            upstream: "https://github.com/dyhkwong/Exclave.git" 
            mappings: "dev:dev-2"

          - name: "husi"
            fork: "kafeixiang/husi"
            upstream: "https://github.com/xchacha20-poly1305/husi.git"
            mappings: "dev:dev-2 dev:dev-zt-16 dev:TB3"

    steps:
      # 第一步：拉取你的 Fork 仓库
      - name: Checkout Fork
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.fork }}
          token: ${{ secrets.PAT_TOKEN }} # 使用你设置的个人访问令牌
          fetch-depth: 0                   # 设为 0 以获取完整 Git 提交历史（Rebase 必选）

      # 第二步：执行核心同步逻辑
      - name: Sync and Notify
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }} # 将 Token 注入环境变量，供 GitHub CLI 创建 PR 使用
        run: |
          # 1. 设置 Git 身份信息
          git config --global user.name "kafeixiang"
          git config --global user.email "kafeixiang@example.com"
          
          # 2. 添加上游仓库
          git remote add upstream ${{ matrix.upstream }}
          
          # 3. 循环处理映射
          for pair in ${{ matrix.mappings }}; do
            UP_BR=${pair%%:*}       # 获取冒号前的部分：上游分支名
            RAW_LOCAL_BR=${pair#*:} # 获取冒号后的部分：原始本地分支名
            
            if [[ "$RAW_LOCAL_BR" == *! ]]; then
              METHOD="reset"; LOCAL_BR=${RAW_LOCAL_BR%!}
            else
              METHOD="rebase"; LOCAL_BR=$RAW_LOCAL_BR
            fi
            
            echo ">>>> [${{ matrix.name }}] 处理分支同步: $UP_BR -> $LOCAL_BR (模式: $METHOD)"
            
            # 4. 获取最新代码
            git fetch upstream $UP_BR --quiet
            git fetch origin $LOCAL_BR --quiet || true
            
            # 5. 确保切换到正确的本地分支
            if git rev-parse --verify origin/$LOCAL_BR >/dev/null 2>&1; then
              git checkout -B $LOCAL_BR origin/$LOCAL_BR
            else
              git checkout -b $LOCAL_BR upstream/$UP_BR
            fi

            if [ "$METHOD" == "reset" ]; then
              # 强制覆盖模式
              git reset --hard upstream/$UP_BR
              git push origin $LOCAL_BR --force
              echo ">>>> [成功] $LOCAL_BR 已重置为上游最新状态"
            else
              # --- 执行 Rebase（变基） ---
              if git rebase upstream/$UP_BR; then
                git push origin $LOCAL_BR --force
                echo ">>>> [成功] $LOCAL_BR 变基同步完成"
                
                # 同步成功后，自动关闭并删除该分支之前的冲突 PR
                gh pr list --repo "${{ matrix.fork }}" --base "$LOCAL_BR" --state open --json number,title | jq -c '.[]' | while read -r pr; do
                  if [[ $(echo "$pr" | jq -r '.title') == *"冲突提醒"* ]]; then
                    PR_NUM=$(echo "$pr" | jq -r '.number')
                    echo ">>>> [清理] 同步已恢复，关闭旧 PR #$PR_NUM"
                    gh pr close --repo "${{ matrix.fork }}" "$PR_NUM" --delete-branch || true
                  fi
                done
              else
                # 发生冲突
                echo ">>>> [冲突] $LOCAL_BR 变基失败，正在创建冲突提醒 PR..."
                git rebase --abort
                
                # A. 清理该分支旧的冲突 PR
                gh pr list --repo "${{ matrix.fork }}" --base "$LOCAL_BR" --state open --json number,title | jq -c '.[]' | while read -r pr; do
                  if [[ $(echo "$pr" | jq -r '.title') == *"冲突提醒"* ]]; then
                    PR_NUM=$(echo "$pr" | jq -r '.number')
                    gh pr close --repo "${{ matrix.fork }}" "$PR_NUM" --delete-branch || true
                  fi
                done
                
                # B. 创建新的临时冲突分支（包含本地分支名以示区分）
                TEMP_BR="sync-alert-${LOCAL_BR}-$(date +%s)"
                git checkout -b $TEMP_BR upstream/$UP_BR
                git push origin $TEMP_BR
                
                # C. 创建 PR 到对应的本地分支
                gh pr create \
                  --repo "${{ matrix.fork }}" \
                  --base "$LOCAL_BR" \
                  --head "$TEMP_BR" \
                  --title "🚨 冲突提醒：${{ matrix.name }} [$LOCAL_BR] 同步受阻" \
                  --body "自动化脚本发现上游 $UP_BR 分支与本地 $LOCAL_BR 分支存在冲突。
                  
                  **处理建议：**
                  1. 在本地切换到 \`$LOCAL_BR\` 分支。
                  2. 执行 \`git pull upstream $UP_BR --rebase\`。
                  3. 解决冲突后推送到 origin。
                  4. 下次同步成功时，此 PR 会自动关闭并删除临时分支。"
              fi
            fi
          done
          echo ">>>> [完成] 所有映射处理完毕。"
