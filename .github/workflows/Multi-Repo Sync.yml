# 工作流名称：每小时多仓库自动同步（变基/强制覆盖模式）
name: Multi-Repo Sync (Safety PR Mode)

on:
  schedule:
    - cron: '0 * * * *' # 定时触发：每小时的第 0 分钟运行一次（例如 1:00, 2:00...）
  workflow_dispatch:      # 手动触发：允许你在 GitHub 页面上点击按钮立即运行

jobs:
  rebase-sync:
    runs-on: ubuntu-latest # 使用 GitHub 提供的最新版 Ubuntu 虚拟机
    strategy:
      fail-fast: false     # 核心配置：即使其中一个仓库同步报错，也不要停止，继续处理后面的仓库
      matrix:
        include:
          # --- 待同步仓库清单 ---
          # 格式解析：
          # name: 仅用于日志显示的标签
          # fork: 你的仓库路径（用户名/仓库名）
          # upstream: 原作者的原始仓库地址
          # mappings: 分支对应关系，格式为 "上游分支:本地分支"。
          #           注意：若本地分支名以 ! 结尾（如 Alpha!），则使用强制覆盖（Hard Reset）；否则默认使用变基（Rebase）。

          - name: "mihomo"
            fork: "kafeixiang/mihomo"
            upstream: "https://github.com/MetaCubeX/mihomo.git"
            mappings: "Meta:Meta Alpha:Alpha!" # Meta 变基同步，Alpha 强制同步

          - name: "ClashMetaForAndroid"
            fork: "kafeixiang/ClashMetaForAndroid"
            upstream: "https://github.com/MetaCubeX/ClashMetaForAndroid.git"
            mappings: "main:main update-dependencies:update-dependencies! update-dependencies:dev"

          - name: "sing-box"
            fork: "kafeixiang/sing-box"
            upstream: "https://github.com/SagerNet/sing-box.git"
            mappings: "main-next:main-next"

          - name: "v2rayNG"
            fork: "kafeixiang/v2rayNG"
            upstream: "https://github.com/2dust/v2rayNG.git"
            mappings: "master:dev"

          - name: "v2rayN"
            fork: "kafeixiang/v2rayN"
            upstream: "https://github.com/2dust/v2rayN.git"
            mappings: "master:dev"

         # - name: "v2rayNX"
          #  fork: "kafeixiang/v2rayNX"
           # upstream: "https://github.com/2dust/v2rayN.git"
           # mappings: "master:master"
            
          - name: "NekoBoxForAndroid"
            fork: "kafeixiang/NekoBoxForAndroid"
            upstream: "https://github.com/MatsuriDayo/NekoBoxForAndroid.git"
            mappings: "main:dev"

        #  - name: "Xray"
         #   fork: "kafeixiang/Xray"
         #   upstream: "https://github.com/XTLS/Xray-core.git
          #  mappings: "main:main"

          - name: "FlClash"
            fork: "kafeixiang/FlClash"
            upstream: "https://github.com/chen08209/FlClash.git"
            mappings: "main:main dev:dev!"

          - name: "Exclave"
            fork: "kafeixiang/Exclave"
            upstream: "https://github.com/dyhkwong/Exclave.git" 
            mappings: "dev:dev-2"

          - name: "husi"
            fork: "kafeixiang/husi"
            upstream: "https://github.com/xchacha20-poly1305/husi.git"
            mappings: "dev:dev-2 dev:dev-zt-16 dev:TB3"

    steps:
      # 第一步：使用 [actions/checkout](https://github.com) 拉取你的 Fork 仓库
      - name: Checkout Fork
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.fork }}
          token: ${{ secrets.PAT_TOKEN }} # 使用你设置的个人访问令牌
          fetch-depth: 0                   # 设为 0 以获取完整 Git 提交历史（Rebase 必选）

      # 第二步：执行核心同步逻辑
      - name: Sync and Notify
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }} # 将 Token 注入环境变量，供 GitHub CLI 创建 PR 使用
        run: |
          # 1. 设置 Git 身份信息（Action 机器人）
          git config --global user.name "kafeixiang"
          git config --global user.email "kafeixiang@example.com"
          
          # 2. 添加并拉取上游远程仓库
          git remote add upstream ${{ matrix.upstream }}
          
          # 3. 循环处理 mappings 字符串中的每一组分支对
          for pair in ${{ matrix.mappings }}; do
            UP_BR=${pair%%:*}       # 获取冒号前的部分：上游分支名
            RAW_LOCAL_BR=${pair#*:} # 获取冒号后的部分：原始本地分支名
            
            # 4. 判断同步模式
            if [[ "$RAW_LOCAL_BR" == *! ]]; then
              METHOD="reset"; LOCAL_BR=${RAW_LOCAL_BR%!} # 剥离感叹号
            else
              METHOD="rebase"; LOCAL_BR=$RAW_LOCAL_BR
            fi
            
            echo ">>>> [${{ matrix.name }}] 同步分支 $UP_BR 到 $LOCAL_BR (模式: $METHOD)"
            
            # 5. 获取上游最新代码
            git fetch upstream $UP_BR
            
            # 6. 检出本地分支（若不存在则基于上游创建新分支）
            git checkout $LOCAL_BR || git checkout -b $LOCAL_BR upstream/$UP_BR

            if [ "$METHOD" == "reset" ]; then
              # --- 执行 Hard Reset（强制覆盖） ---
              git reset --hard upstream/$UP_BR
              git push origin $LOCAL_BR --force # 强制推送到你的仓库
              echo ">>>> [成功] 分支 $LOCAL_BR 已完成强制同步"
            else
              # --- 执行 Rebase（变基） ---
              if git rebase upstream/$UP_BR; then
                git push origin $LOCAL_BR --force # 变基成功，强推
                echo ">>>> [成功] 分支 $LOCAL_BR 已完成变基同步"
              else
                # --- 发生冲突时的安全处理 ---
                echo ">>>> [冲突] 变基失败！正在处理冲突分支..."
                git rebase --abort # 撤销失败的变基，恢复分支原状
                
                # A. 清理旧的冲突分支（增加本地分支名区分，避免误删其他分支的 PR）
                OLD_CONFLICT_BRS=$(git branch -r --list "origin/sync-alert-${UP_BR}-to-${LOCAL_BR}-*" 2>/dev/null)
                if [ -n "$OLD_CONFLICT_BRS" ]; then
                  echo ">>>> [清理] 删除旧的冲突分支..."
                  for old_br in $OLD_CONFLICT_BRS; do
                    old_br_name=$(basename "$old_br")
                    git push origin --delete "$old_br_name" 2>/dev/null || true
                    echo ">>>> [已删除] $old_br_name"
                  done
                fi
                
                # B. 创建新的冲突分支（增加本地分支名区分）
                TEMP_BR="sync-alert-${UP_BR}-to-${LOCAL_BR}-$(date +%s)"
                git checkout -b $TEMP_BR upstream/$UP_BR
                git push origin $TEMP_BR
                
                # C. 使用 [gh pr create](https://cli.github.com) 发起 PR 提醒
                gh pr create \
                  --repo "${{ matrix.fork }}" \
                  --base "$LOCAL_BR" \
                  --head "$TEMP_BR" \
                  --title "🚨 冲突提醒：${{ matrix.name }} [$LOCAL_BR] 同步受阻" \
                  --body "自动化脚本发现上游 $UP_BR 分支与你本地的 $LOCAL_BR 存在代码冲突。你可以合并此 PR 来完成同步，或在本地手动解决冲突。注意：此 PR 仅存在于你自己的仓库内部。" \
                  2>/dev/null || echo ">>>> [提示] PR 已存在或创建失败"
              fi
            fi
          done
